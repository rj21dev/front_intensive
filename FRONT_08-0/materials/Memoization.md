## React.memo

Поскольку компоненты — это всего лишь функции, их можно мемоизировать с помощью React.memo(). Это предотвратит повторный рендеринг компонента, если не изменились зависимости (пропсы). Если у вас есть особенно тяжелый компонент, то лучше его мемоизировать, но не стоит делать так с каждым. Мемоизация задействует память и в некоторых случаях может снижать производительность.

Когда компонент мемоизируется, вместо повторного рендеринга React сравнивает новые пропсы компонента с его предыдущими пропсами. В этом случае необходимо найти оптимальное решение в зависимости от интенсивности процессов сравнения пропсов и выполнения функции. Если в пропсах содержится большой объект, то мемоизация компонента может плохо повлиять на производительность.
```
const HeavyComponent: FC = () => { return <div/>}
export const Heavy = React.memo(HeavyComponent);
```

## useMemo

Мы уже знаем, что каждый ререндеринг означает повторный вызов функции компонента. Таким образом, если функция компонента включает вызов дорогой функции, то эта дорогая функция будет вызываться при каждом повторном рендеринге. Чтобы этого избежать, можно ее мемоизировать. Первый рендеринг вызовет функцию, а последующие будут возвращать ее кэшированные результаты вместо того, чтобы запускать ее снова.

Хук useMemo намного упрощает реализацию мемоизации:

```
const value = useMemo(() => expensiveFunction(aDep), [aDep]);
```

В данном примере значение будет кэшироваться и обновляться только при изменении aDep.

## useCallback

Важным инструментом, предотвращающим ненужный повторный рендеринг мемоизированных компонентов, является useCallback. При передаче функции в мемоизированный компонент вы можете нечаянно устранить эффект мемоизации, не мемоизируя эту функцию с помощью useCallback. Причина — в равенстве ссылок.

Как упоминалось ранее, при каждом повторном рендеринге вызывается функция компонента. Это означает, что если мы объявляем функцию в компоненте, то при каждом повторном рендеринге создается новая функция. Когда мы передаем эту функцию в качестве пропса другому компоненту, происходит изменение ссылки, даже если содержимое функции фактически не меняется. Это заставляет дочерний компонент ререндериться, даже если он мемоизирован.

```
export const ParentComponent = () => {
  const handleSomething = () => {};
  return <HeavyComponent onSomething={handleSomething} />
};
```

В этом примере каждый раз, когда ParentComponent ререндерится, HeavyComponent тоже ререндерится, несмотря на то, что он мемоизирован. Мы можем исправить это, используя useCallback и предотвращая изменение ссылки.

```
export const ParentComponent = () => {
  const handleSomething = useCallback(() => {}, []);
  return <HeavyComponent onSomething={handleSomething} />
};
```
