## Generic Types

Допустим, у нас есть функция, принимающая на вход один аргумент и возвращающая его же без каких-либо изменений. Такая функция присутствует во многих библиотеках функционального программирования и носит имя identity.

```
function identity(arg: any): any {
	return arg;
}
```

Сейчас функция представляет собой «чёрный ящик», в который с одной стороны что-то входит, а с другой стороны что-то выходит, возможно, похожее на то, что входило или нет – непонятно.

Теперь перепишем функцию так, чтобы каждый из нас знал, что тип переданного аргумента является и типом возвращаемого значения.

```
function identity<T>(arg: T): T {
	return arg;
}
```

Здесь T – это некоторый параметр-тип T, который будет захвачен при вызове функции. Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T.
Можно использовать любые буквы, которые вам хочется, но буквы на входе и выходе функции должны совпадать, если этого требует логика её работы. Так уж сложилось, что, если имеется единственный параметр-тип, то он получает имя T, но лишь в том случае, если это не нарушает общую ясность. 

Попробуем вызвать эту функцию с аргументом типа number и поверхностно проследим за тем, как компилятор определяет, что вернёт функция.

```
const value = identity<number>(115);
```

При вызове функции тип <number> заполняет обобщённый параметр T. В этот момент компилятор неявно подставляет вместо T переданный тип number и переходит к валидации типов переданных аргументов, а затем входит внутрь функции и валидирует её тело.

## Для чего существуют обобщённые типы

При написании кода вы всегда встаёте перед выбором, имеющим как минимум две ветви решения. Первый путь приводит вас к копированию существующего кода с нужным вам типом, что также приводит к «распуханию» кода и необходимости думать при рефакторинге. Второй путь – унификация, что подразумевает под собой параметрический полиморфизм, в основе которого лежит использование одного и того же кода, но с разными типами. Получается, что обобщённые типы нужны для написания кода, который можно многократно использовать вне зависимости от типов.
